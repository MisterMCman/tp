generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Country {
  id                Int               @id @default(autoincrement())
  name              String            @unique
  code              String            @unique // ISO 3166-1 alpha-2
  phoneCode         String?           // International phone code
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  trainers          Trainer[]
  trainingCompanies TrainingCompany[]
}

model Trainer {
  id           Int           @id @default(autoincrement())
  userType     UserType      @default(TRAINER)
  firstName    String
  lastName     String
  email        String        @unique
  phone        String
  address      String?       @db.Text // Legacy field, kept for backward compatibility
  street       String?       // Straße
  houseNumber  String?       // Hausnummer
  zipCode      String?       // PLZ
  city         String?       // Stadt
  bio          String?       @db.Text
  profilePicture String?
  iban         String?       // IBAN for bank transfers
  taxId        String?
  companyName  String?       // Firmenname falls es eine GmbH ist
  isCompany    Boolean       @default(false) // Gibt an ob es sich um eine Firma handelt
  dailyRate    Float?        // Regulärer Netto-Tagessatz für Schulungen 9-16 Uhr
  status       TrainerStatus @default(ACTIVE)
  countryId    Int?          // Reference to Country
  country      Country?      @relation(fields: [countryId], references: [id])
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  inquiries    Inquiry[]
  invoices     Invoice[]
  topics       TrainerTopic[]
  loginTokens  LoginToken[]
  topicSuggestions TopicSuggestion[]
  profileVersions TrainerProfileVersion[]
  availabilities Availability[]
  trainingRequests TrainingRequest[]

  @@index([countryId], map: "Trainer_countryId_fkey")
}

model TrainingCompany {
  id           Int                  @id @default(autoincrement())
  userType     UserType             @default(TRAINING_COMPANY)
  companyName  String               // Company name
  contactName  String?              // Contact person name (legacy, kept for backward compatibility)
  firstName    String?              // Contact person first name
  lastName     String?              // Contact person last name
  email        String               @unique
  phone        String
  address      String?              @db.Text // Legacy field, kept for backward compatibility
  street       String?              // Straße
  houseNumber  String?              // Hausnummer
  zipCode      String?              // PLZ
  city         String?              // Stadt
  domain       String?              // Extracted from email for company identification
  bio          String?              @db.Text
  logo         String?              // Company logo URL
  website      String?              // Company website
  industry     String?              // Industry/sector
  employees    String?              // Company size (e.g., "1-10", "11-50", "51-200", "200+")
  vatId        String?              // Umsatzsteuer-ID
  consultantName String?            // Name of the consultant using the platform
  billingEmail String?              // Separate billing email
  billingNotes String?              @db.Text // Additional billing notes
  tags         String?              @db.Text // Tags/Keywords (JSON or comma-separated)
  onboardingStatus String?          // Onboarding status (e.g., "Profil unvollständig")
  status       TrainerStatus        @default(ACTIVE)
  countryId    Int?                 // Reference to Country
  country      Country?             @relation(fields: [countryId], references: [id])
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  inquiries    Inquiry[]
  loginTokens  TrainingCompanyLoginToken[]
  trainings    Training[]

  @@index([countryId], map: "TrainingCompany_countryId_fkey")
}

model TrainingCompanyLoginToken {
  id                 Int             @id @default(autoincrement())
  token              String          @unique
  trainingCompanyId  Int
  trainingCompany    TrainingCompany @relation(fields: [trainingCompanyId], references: [id])
  createdAt          DateTime        @default(now())
  expiresAt          DateTime
  // Note: Tokens are now reusable within expiration period
  used               Boolean         @default(false) // For future use, currently not enforced
  usedAt             DateTime?       // Tracks last usage timestamp

  @@index([trainingCompanyId], map: "TrainingCompanyLoginToken_trainingCompanyId_fkey")
}

model LoginToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  trainerId Int
  trainer   Trainer  @relation(fields: [trainerId], references: [id])
  createdAt DateTime @default(now())
  expiresAt DateTime
  // Note: Tokens are now reusable within expiration period
  used      Boolean  @default(false) // For future use, currently not enforced
  usedAt    DateTime? // Tracks last usage timestamp

  @@index([trainerId], map: "LoginToken_trainerId_fkey")
}

model Topic {
  id            Int              @id @default(autoincrement())
  state         String           @default("online") // online/offline
  slug          String           @unique
  name          String           // title from CSV
  short_title   String?
  icon          String?
  novelty_order Int?
  featured_order Int?
  teaser_title  String?
  teaser_text   String?          @db.Text
  detail_title  String?
  detail_text   String?          @db.Text
  seo_text      String?          @db.Text
  order         Int?
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  trainers      TrainerTopic[]
  courses       Course[]
  trainings     Training[]
}

model TrainerTopic {
  id        Int      @id @default(autoincrement())
  trainer   Trainer  @relation(fields: [trainerId], references: [id])
  trainerId Int
  topic     Topic    @relation(fields: [topicId], references: [id])
  topicId   Int
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  @@unique([trainerId, topicId]) // Eindeutiger Index statt Primärschlüssel
}

model TopicSuggestion {
  id        Int                 @id @default(autoincrement())
  name      String
  trainer   Trainer             @relation(fields: [trainerId], references: [id])
  trainerId Int
  status    TopicSuggestionStatus @default(PENDING)
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt

  @@index([trainerId], map: "TopicSuggestion_trainerId_fkey")
  @@index([name], map: "TopicSuggestion_name_idx")
}

model TrainerProfileVersion {
  id            Int      @id @default(autoincrement())
  trainerId     Int
  trainer       Trainer  @relation(fields: [trainerId], references: [id])
  version       Int      // Version number for this trainer
  firstName     String?
  lastName      String?
  email         String?
  phone         String?
  address       String?
  countryId     Int?
  bio           String?
  profilePicture String?
  iban          String?
  taxId         String?
  companyName   String?
  isCompany     Boolean?
  dailyRate     Float?
  changedFields String   // JSON string of changed field names
  changedBy     String   // 'trainer' or 'admin'
  createdAt     DateTime @default(now())

  @@index([trainerId], map: "TrainerProfileVersion_trainerId_fkey")
  @@index([trainerId, version], map: "TrainerProfileVersion_trainerId_version_key")
}

model Inquiry {
  id                 Int                 @id @default(autoincrement())
  trainerId          Int
  trainingCompanyId  Int?
  eventId            Int
  status             InquiryStatus       @default(PENDING)
  originalPrice      Float
  proposedPrice      Float
  counterPrice       Float?
  message            String?             @db.Text
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  event              Event               @relation(fields: [eventId], references: [id])
  trainer            Trainer             @relation(fields: [trainerId], references: [id])
  trainingCompany    TrainingCompany?    @relation(fields: [trainingCompanyId], references: [id])

  @@index([eventId], map: "Inquiry_eventId_fkey")
  @@index([trainerId], map: "Inquiry_trainerId_fkey")
  @@index([trainingCompanyId], map: "Inquiry_trainingCompanyId_fkey")
}

model Event {
  id           Int           @id @default(autoincrement())
  courseId     Int
  title        String
  date         DateTime
  endTime      DateTime
  location     String
  participants Int           @default(0)
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  course       Course        @relation(fields: [courseId], references: [id])
  inquiries    Inquiry[]
  eventParticipants Participant[]

  @@index([courseId], map: "Event_courseId_fkey")
}

model Course {
  id          Int         @id @default(autoincrement())
  description String?     @db.Text
  createdAt   DateTime    @default(now())
  state       CourseState @default(ONLINE)
  title       String
  topicId     Int?
  topic       Topic?      @relation(fields: [topicId], references: [id])
  updatedAt   DateTime    @updatedAt
  events      Event[]

  @@index([topicId], map: "Course_topicId_fkey")
}

model Participant {
  id      Int    @id @default(autoincrement())
  name    String
  email   String
  eventId Int
  event   Event  @relation(fields: [eventId], references: [id])

  @@index([eventId], map: "Participant_eventId_fkey")
}

model Invoice {
  id        Int           @id @default(autoincrement())
  trainerId Int
  courseId  Int?
  amount    Float
  status    InvoiceStatus @default(SUBMITTED)
  createdAt DateTime      @default(now())
  trainer   Trainer       @relation(fields: [trainerId], references: [id])

  @@index([trainerId], map: "Invoice_trainerId_fkey")
}

enum UserType {
  TRAINER
  TRAINING_COMPANY
}

enum TrainerStatus {
  ACTIVE
  INACTIVE
}

enum InquiryStatus {
  PENDING
  ACCEPTED
  REJECTED
  ABGESAGT
  COMPLETED
}

enum CourseState {
  ONLINE
  INACTIVE
}

enum InvoiceStatus {
  SUBMITTED
  PAID
}

model Availability {
  id        Int      @id @default(autoincrement())
  trainerId Int
  trainer   Trainer  @relation(fields: [trainerId], references: [id])
  dayOfWeek Int      // 0 = Sunday, 1 = Monday, etc.
  startTime String   // Format: "HH:mm"
  endTime   String   // Format: "HH:mm"
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([trainerId], map: "Availability_trainerId_fkey")
}

enum TopicSuggestionStatus {
  PENDING
  APPROVED
  REJECTED
}

model Training {
  id                 Int              @id @default(autoincrement())
  title              String
  topicId            Int
  topic              Topic            @relation(fields: [topicId], references: [id])
  companyId          Int
  company            TrainingCompany  @relation(fields: [companyId], references: [id])
  startDate          DateTime
  endDate            DateTime
  startTime          String           // Format: "HH:mm"
  endTime            String           // Format: "HH:mm"
  location           String
  participants       Int
  dailyRate          Float
  description        String?          @db.Text
  status             TrainingStatus   @default(DRAFT)
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  requests           TrainingRequest[]

  @@index([companyId], map: "Training_companyId_fkey")
  @@index([topicId], map: "Training_topicId_fkey")
}

model TrainingRequest {
  id          Int                @id @default(autoincrement())
  trainingId  Int
  training    Training           @relation(fields: [trainingId], references: [id])
  trainerId   Int
  trainer     Trainer            @relation(fields: [trainerId], references: [id])
  status      TrainingRequestStatus @default(PENDING)
  message     String?            @db.Text
  counterPrice Float?            // Counter offer price from trainer
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  inquiryMessages InquiryMessage[]

  @@unique([trainingId, trainerId])
  @@index([trainerId], map: "TrainingRequest_trainerId_fkey")
  @@index([trainingId], map: "TrainingRequest_trainingId_fkey")
}

enum TrainingStatus {
  DRAFT
  PUBLISHED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum TrainingRequestStatus {
  PENDING
  ACCEPTED
  DECLINED
  WITHDRAWN
}

model FileAttachment {
  id                 Int             @id @default(autoincrement())
  inquiryMessageId   Int
  inquiryMessage     InquiryMessage  @relation(fields: [inquiryMessageId], references: [id], onDelete: Cascade)
  filename           String          // Original filename
  storedFilename     String          // Unique filename on disk
  filePath           String          // Full path to file on disk
  fileSize           Int             // File size in bytes
  mimeType           String          // MIME type (e.g., "application/pdf")
  uploadedAt         DateTime        @default(now())

  @@index([inquiryMessageId], map: "FileAttachment_inquiryMessageId_fkey")
}

model InquiryMessage {
  id                 Int                 @id @default(autoincrement())
  trainingRequestId  Int
  trainingRequest    TrainingRequest     @relation(fields: [trainingRequestId], references: [id])
  senderId           Int                 // Can be trainer or company ID
  senderType         UserType            // TRAINER or TRAINING_COMPANY
  recipientId        Int                 // Can be trainer or company ID
  recipientType      UserType            // TRAINER or TRAINING_COMPANY
  subject            String              // Subject line for the message
  message            String              @db.Text
  isRead             Boolean             @default(false)
  attachments        FileAttachment[]    // File attachments
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt

  @@index([trainingRequestId], map: "InquiryMessage_trainingRequestId_fkey")
  @@index([senderId], map: "InquiryMessage_senderId_fkey")
  @@index([recipientId], map: "InquiryMessage_recipientId_fkey")
}

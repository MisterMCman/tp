generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Country {
  id                Int               @id @default(autoincrement())
  name              String            @unique
  code              String            @unique // ISO 3166-1 alpha-2
  phoneCode         String? // International phone code
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  trainers          Trainer[]
  trainingCompanies TrainingCompany[]
  locations         Location[]
}

model Trainer {
  id                   Int                     @id @default(autoincrement())
  userType             UserType                @default(TRAINER)
  firstName            String
  lastName             String
  email                String                  @unique
  phone                String
  street               String? // Straße
  houseNumber          String? // Hausnummer
  zipCode              String? // PLZ
  city                 String? // Stadt
  bio                  String?                 @db.Text
  profilePicture       String?
  iban                 String? // IBAN for bank transfers
  taxId                String?
  companyName          String? // Firmenname falls es eine GmbH ist
  isCompany            Boolean                 @default(false) // Gibt an ob es sich um eine Firma handelt
  dailyRate            Float? // Regulärer Netto-Tagessatz für Schulungen 9-16 Uhr
  status               TrainerStatus           @default(ACTIVE)
  countryId            Int? // Reference to Country
  country              Country?                @relation(fields: [countryId], references: [id])
  travelRadius         Int? // Travel radius in km from trainer's address
  latitude             Float? // Latitude of trainer's address (for distance calculations)
  longitude            Float? // Longitude of trainer's address (for distance calculations)
  offeredTrainingTypes TrainerTrainingType[] // Types of training the trainer offers (ONLINE, HYBRID, VOR_ORT)
  createdAt            DateTime                @default(now())
  updatedAt            DateTime                @updatedAt
  invoices             Invoice[]
  topics               TrainerTopic[]
  loginTokens          LoginToken[]
  topicSuggestions     TopicSuggestion[]
  profileVersions      TrainerProfileVersion[]
  availabilities       Availability[]
  trainingRequests     TrainingRequest[]
  ratings              TrainingRating[] // Ratings received by this trainer

  @@index([countryId], map: "Trainer_countryId_fkey")
}

model TrainingCompany {
  id               Int                         @id @default(autoincrement())
  userType         UserType                    @default(TRAINING_COMPANY)
  companyName      String // Company name
  phone            String? // Legacy phone (use users table)
  street           String // Straße (required)
  houseNumber      String // Hausnummer (required)
  zipCode          String // PLZ (required)
  city             String // Stadt (required)
  domain           String? // Extracted from email for company identification
  bio              String?                     @db.Text
  logo             String? // Company logo URL
  website          String? // Company website
  industry         String? // Industry/sector
  employees        String? // Company size (e.g., "1-10", "11-50", "51-200", "200+")
  companyType      CompanyType? // Company legal form (GmbH, GbR, UG, etc.)
  vatId            String? // Umsatzsteuer-ID
  iban             String? // IBAN for bank transfers
  taxId            String? // Steuernummer (tax ID)
  billingEmail     String? // Separate billing email
  billingNotes     String?                     @db.Text // Additional billing notes
  tags             String? // Tags for categorization
  onboardingStatus String? // Onboarding status (e.g., "Profil unvollständig")
  status           TrainerStatus               @default(ACTIVE)
  countryId        Int // Reference to Country (required)
  country          Country?                    @relation(fields: [countryId], references: [id])
  createdAt        DateTime                    @default(now())
  updatedAt        DateTime                    @updatedAt
  trainings        Training[]
  users            CompanyUser[] // Users associated with this company
  locations        Location[] // Reusable locations owned by this company
  ratings          TrainingRating[] // Ratings given by this company

  @@index([countryId], map: "TrainingCompany_countryId_fkey")
}

model CompanyUser {
  id               Int                         @id @default(autoincrement())
  email            String                      @unique
  firstName        String
  lastName         String
  phone            String?
  role             CompanyUserRole             @default(EDITOR)
  isActive         Boolean                     @default(true)
  companyId        Int
  company          TrainingCompany             @relation(fields: [companyId], references: [id], onDelete: Cascade)
  loginTokens      CompanyUserLoginToken[]
  createdAt        DateTime                    @default(now())
  updatedAt        DateTime                    @updatedAt

  @@index([companyId], map: "CompanyUser_companyId_fkey")
  @@index([email], map: "CompanyUser_email_idx")
}

model CompanyUserLoginToken {
  id        Int          @id @default(autoincrement())
  token     String       @unique
  userId    Int
  user      CompanyUser  @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime     @default(now())
  expiresAt DateTime
  used      Boolean      @default(false)
  usedAt    DateTime?

  @@index([userId], map: "CompanyUserLoginToken_userId_fkey")
}

model LoginToken {
  id        Int       @id @default(autoincrement())
  token     String    @unique
  trainerId Int
  trainer   Trainer   @relation(fields: [trainerId], references: [id])
  createdAt DateTime  @default(now())
  expiresAt DateTime
  // Note: Tokens are now reusable within expiration period
  used      Boolean   @default(false) // For future use, currently not enforced
  usedAt    DateTime? // Tracks last usage timestamp

  @@index([trainerId], map: "LoginToken_trainerId_fkey")
}

model Topic {
  id             Int            @id @default(autoincrement())
  state          String         @default("online") // online/offline
  slug           String         @unique
  name           String // title from CSV
  short_title    String?
  icon           String?
  novelty_order  Int?
  featured_order Int?
  teaser_title   String?
  teaser_text    String?        @db.Text
  detail_title   String?
  detail_text    String?        @db.Text
  seo_text       String?        @db.Text
  order          Int?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  trainers       TrainerTopic[]
  courses        Course[]
  trainings      Training[]
  ratings        TrainingRating[] // Ratings for trainings on this topic
}

enum ExpertiseLevel {
  GRUNDLAGE
  FORTGESCHRITTEN
  EXPERTE
}

model TrainerTopic {
  id             Int            @id @default(autoincrement())
  trainer        Trainer        @relation(fields: [trainerId], references: [id])
  trainerId      Int
  topic          Topic          @relation(fields: [topicId], references: [id])
  topicId        Int
  expertiseLevel ExpertiseLevel @default(GRUNDLAGE)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  @@unique([trainerId, topicId]) // Eindeutiger Index statt Primärschlüssel
}

model TopicSuggestion {
  id        Int                   @id @default(autoincrement())
  name      String
  trainer   Trainer               @relation(fields: [trainerId], references: [id])
  trainerId Int
  status    TopicSuggestionStatus @default(PENDING)
  createdAt DateTime              @default(now())
  updatedAt DateTime              @updatedAt

  @@index([trainerId], map: "TopicSuggestion_trainerId_fkey")
  @@index([name], map: "TopicSuggestion_name_idx")
}

model TrainerProfileVersion {
  id             Int      @id @default(autoincrement())
  trainerId      Int
  trainer        Trainer  @relation(fields: [trainerId], references: [id])
  version        Int // Version number for this trainer
  firstName      String?
  lastName       String?
  email          String?
  phone          String?
  street         String?
  houseNumber    String?
  zipCode        String?
  city           String?
  countryId      Int?
  bio            String?
  profilePicture String?
  iban           String?
  taxId          String?
  companyName    String?
  isCompany      Boolean?
  dailyRate      Float?
  changedFields  String // JSON string of changed field names
  changedBy      String // 'trainer' or 'admin'
  createdAt      DateTime @default(now())

  @@index([trainerId], map: "TrainerProfileVersion_trainerId_fkey")
  @@index([trainerId, version], map: "TrainerProfileVersion_trainerId_version_key")
}

model Course {
  id          Int         @id @default(autoincrement())
  title       String
  description String?     @db.Text
  topicId     Int?
  topic       Topic?      @relation(fields: [topicId], references: [id])
  state       CourseState @default(ONLINE)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  trainings   Training[] // One course can have multiple trainings

  @@index([topicId], map: "Course_topicId_fkey")
}

model Participant {
  id         Int      @id @default(autoincrement())
  name       String? // Optional - can be anonymous
  email      String? // Optional
  trainingId Int
  training   Training @relation(fields: [trainingId], references: [id])
  createdAt  DateTime @default(now())

  @@index([trainingId], map: "Participant_trainingId_fkey")
}

model Invoice {
  id            Int           @id @default(autoincrement())
  trainerId     Int
  trainingId    Int?
  training      Training?     @relation(fields: [trainingId], references: [id])
  amount        Float
  status        InvoiceStatus @default(SUBMITTED)
  invoiceNumber String?       @unique // e.g., "INV-2024-001"
  invoiceDate   DateTime?
  paidDate      DateTime?
  createdAt     DateTime      @default(now())
  trainer       Trainer       @relation(fields: [trainerId], references: [id])

  @@index([trainerId], map: "Invoice_trainerId_fkey")
  @@index([trainingId], map: "Invoice_trainingId_fkey")
}

enum UserType {
  TRAINER
  TRAINING_COMPANY
}

enum CompanyUserRole {
  ADMIN    // Can manage company and all users
  EDITOR   // Can use all features but only edit own data
  VIEWER   // Can only view data, cannot make requests or change data (except own user details)
}

enum CompanyType {
  GMBH     // Gesellschaft mit beschränkter Haftung
  GBR      // Gesellschaft bürgerlichen Rechts
  UG       // Unternehmergesellschaft (haftungsbeschränkt)
  EK       // Einzelkaufmann / Einzelkauffrau
  AG       // Aktiengesellschaft
  KG       // Kommanditgesellschaft
  OHG      // Offene Handelsgesellschaft
  PARTG    // Partnerschaftsgesellschaft
  SONSTIGE // Sonstige Rechtsform
}

enum TrainerStatus {
  ACTIVE
  INACTIVE
}

enum CourseState {
  ONLINE
  INACTIVE
}

enum InvoiceStatus {
  SUBMITTED
  PAID
}

enum TrainingType {
  ONLINE
  HYBRID
  VOR_ORT
}

model TrainerTrainingType {
  id        Int          @id @default(autoincrement())
  trainerId Int
  trainer   Trainer      @relation(fields: [trainerId], references: [id], onDelete: Cascade)
  type      TrainingType
  createdAt DateTime     @default(now())

  @@unique([trainerId, type])
  @@index([trainerId], map: "TrainerTrainingType_trainerId_fkey")
}

model Availability {
  id        Int      @id @default(autoincrement())
  trainerId Int
  trainer   Trainer  @relation(fields: [trainerId], references: [id])
  dayOfWeek Int // 0 = Sunday, 1 = Monday, etc.
  startTime String // Format: "HH:mm"
  endTime   String // Format: "HH:mm"
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([trainerId], map: "Availability_trainerId_fkey")
}

enum TopicSuggestionStatus {
  PENDING
  APPROVED
  REJECTED
}

model Location {
  id                  Int               @id @default(autoincrement())
  name                String // Display name (e.g., "Zoom Meeting", "Microsoft Teams", "Berlin Office")
  type                LocationType      @default(ONLINE) // ONLINE, PHYSICAL
  companyId           Int? // If set, this is a reusable location owned by a company
  company             TrainingCompany?  @relation(fields: [companyId], references: [id])
  // For ONLINE locations
  onlinePlatform      String? // "ZOOM", "TEAMS", "GOOGLE_MEET", "OTHER"
  onlineLink          String? // Meeting link or platform identifier
  // For PHYSICAL locations
  street              String?
  houseNumber         String?
  zipCode             String?
  city                String?
  countryId           Int?
  country             Country?          @relation(fields: [countryId], references: [id])
  latitude            Float? // Latitude for distance calculations (only for PHYSICAL)
  longitude           Float? // Longitude for distance calculations (only for PHYSICAL)
  description         String?           @db.Text
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  trainings           Training[] // Trainings using this location

  @@index([countryId])
  @@index([companyId])
}

enum LocationType {
  ONLINE
  PHYSICAL
}

model Training {
  id                  Int               @id @default(autoincrement())
  courseId            Int? // Reference to Course template
  course              Course?           @relation(fields: [courseId], references: [id])
  title               String
  topicId             Int
  topic               Topic             @relation(fields: [topicId], references: [id])
  companyId           Int
  company             TrainingCompany   @relation(fields: [companyId], references: [id])
  startDate           DateTime
  endDate             DateTime
  startTime           String // Format: "HH:mm"
  endTime             String // Format: "HH:mm"
  type                TrainingType      @default(ONLINE) // Training type: ONLINE, HYBRID, or VOR_ORT
  locationId          Int? // Reference to Location
  location            Location?         @relation(fields: [locationId], references: [id])
  participantCount    Int // Number of participants
  dailyRate           Float
  description         String?           @db.Text
  status              TrainingStatus    @default(DRAFT)
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  requests            TrainingRequest[] // Training requests from companies to trainers
  participants        Participant[] // Actual participant records
  invoices            Invoice[] // Generated invoices
  ratings             TrainingRating[] // Ratings given by companies for this training

  @@index([courseId], map: "Training_courseId_fkey")
  @@index([companyId], map: "Training_companyId_fkey")
  @@index([topicId], map: "Training_topicId_fkey")
  @@index([locationId])
}

model TrainingRequest {
  id                  Int                   @id @default(autoincrement())
  trainingId          Int
  training            Training              @relation(fields: [trainingId], references: [id])
  trainerId           Int
  trainer             Trainer               @relation(fields: [trainerId], references: [id])
  status              TrainingRequestStatus @default(PENDING)
  counterPrice        Float? // Counter offer price from trainer
  companyCounterPrice Float? // Counter offer price from company
  trainerAccepted     Boolean               @default(false) // Trainer has accepted, waiting for company approval
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  messages            Message[] // Messages related to this training request

  @@unique([trainingId, trainerId])
  @@index([trainerId], map: "TrainingRequest_trainerId_fkey")
  @@index([trainingId], map: "TrainingRequest_trainingId_fkey")
}

enum TrainingStatus {
  DRAFT
  PUBLISHED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum TrainingRequestStatus {
  PENDING
  ACCEPTED
  GEBUCHT
  DECLINED
  WITHDRAWN
}

model FileAttachment {
  id             Int      @id @default(autoincrement())
  messageId      Int
  message        Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  filename       String // Original filename
  storedFilename String // Unique filename on disk
  filePath       String // Full path to file on disk
  fileSize       Int // File size in bytes
  mimeType       String // MIME type (e.g., "application/pdf")
  uploadedAt     DateTime @default(now())

  @@index([messageId], map: "FileAttachment_messageId_fkey")
}

model Message {
  id                Int              @id @default(autoincrement())
  trainingRequestId Int? // Reference to TrainingRequest (if message is related to a request)
  trainingRequest   TrainingRequest? @relation(fields: [trainingRequestId], references: [id])
  senderId          Int // Trainer or company ID
  senderType        UserType // TRAINER or TRAINING_COMPANY
  recipientId       Int // Trainer or company ID (always the other party)
  recipientType     UserType // TRAINER or TRAINING_COMPANY (always the other party)
  subject           String // Subject line
  message           String           @db.Text
  isRead            Boolean          @default(false)
  messageType       String           @default("GENERAL") // GENERAL, INQUIRY, NOTIFICATION, etc.
  relatedId         Int? // Can reference Inquiry, Training, etc.
  attachments       FileAttachment[] // File attachments
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  @@index([senderId], map: "Message_senderId_fkey")
  @@index([recipientId], map: "Message_recipientId_fkey")
  @@index([trainingRequestId], map: "Message_trainingRequestId_fkey")
}

model TrainingRating {
  id          Int               @id @default(autoincrement())
  trainingId  Int
  training    Training          @relation(fields: [trainingId], references: [id], onDelete: Cascade)
  trainerId   Int // The trainer being rated
  trainer     Trainer           @relation(fields: [trainerId], references: [id], onDelete: Cascade)
  companyId   Int // The company giving the rating
  company     TrainingCompany   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  topicId     Int // The topic of the training
  topic       Topic             @relation(fields: [topicId], references: [id])
  rating      Int // Rating from 1 to 5
  comment     String?           @db.Text // Optional comment
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  @@unique([trainingId, companyId]) // One rating per training per company
  @@index([trainerId], map: "TrainingRating_trainerId_fkey")
  @@index([companyId], map: "TrainingRating_companyId_fkey")
  @@index([topicId], map: "TrainingRating_topicId_fkey")
  @@index([trainingId], map: "TrainingRating_trainingId_fkey")
}
